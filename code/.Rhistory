categorical_feature = factor.vars,
label = y[-valid.selector])
valid.df<- lgb.Dataset.create.valid(dataset = train.df,
data = df[valid.selector,],
label = y[valid.selector])
results[[i]]<- lgb.train(params = parameters, data = train.df,
nrounds = no.trees,
valids = list(my_validation = valid.df),
obj = est.type, verbose = -1, record = TRUE,
categorical_feature = factor.vars,
early_stopping_rounds = early.stopping,
eval = eval.metric)
score.vec[i]<- results[[i]]$best_score
if(isTRUE(error.rate)){
error.rate.vec[i]<- results[[i]]$eval_valid()[[2]]$value
}
}
if(isFALSE(error.rate)){
out<- mean(score.vec)
return(out)
}else{
out<- colMeans(data.frame(score = score.vec, error.pct = error.rate.vec))
return(out)
}
}else{
train.df<- lgb.Dataset(df, categorical_feature = factor.vars, label = y)
out<- lgb.train(params = parameters, data = train.df, nrounds = no.trees,
obj = est.type, verbose = 1, record = TRUE,
categorical_feature = factor.vars, eval = eval.metric)
return(out)
}
}
genetic.algorithm<- function(optim.seed, n = 50, pcrossover = 0.8,
pmutation = 0.1, maxiter = 10, elitism = 4,
digits,
sdi = FALSE, lr, no.leaves, max.depth,
min.data.in.leaf, feature.fraction, cat.l2,
extra.trees = FALSE, top.rate, other.rate,
cat.smooth, path.smooth,
inputdf, y, est_type, alpha = 0.5, cv = 5L,
no_trees = 100L, no_threads = 4L,
early_stopping = 10L, seed = NA){
# A genetic algorithm that adapted from the ga function from the GA-package by Luca Scrucca (doi:10.18637/jss.v053.i04). The loss function is rounded to two significant digits; as secondary fitness evaluation speed is used.
# optim.seed: start seed for optimization
# n: number of members in the population
# pcrossover: probability for chromosomes to merge
# pmutation: probability for a mutation to occur
# maxiter: integer number of generations that are trained
# elitism: integer number of parent models that are permitted to procreate. Sorted best to worst, the first to elitism-th model form the parent model pool.
# digits is an integer vector of length maxiter. The i-th entry in digits gives the number of significant digits to be considered during evolution
# sdi to path.smooth: instead of individual values (like wrapper_interior), takes atomic vectors of length 2 with the lower and upper limit that the respective hyperparameter can take.
# all others: vis-Ã -vis wrapper_interior
results<- list()
limits<- rbind(lr, no.leaves, max.depth, min.data.in.leaf, feature.fraction,
cat.l2, extra.trees, top.rate, other.rate, cat.smooth,
path.smooth)
colnames(limits)<- c("lower","upper")
X<- matrix(NA, nrow = n, ncol = 11)
colnames(X)<- c("lr", "no.leaves", "max.depth", "min.data.in.leaf",
"feature.fraction", "cat.l2", "extra.trees", "top.rate",
"other.rate", "cat.smooth", "path.smooth")
set.seed(optim.seed)
if(isTRUE(sdi)){
sdi_init<- c(NA, NA, NA, 0.45, 0, 0, -0.07975, 0, 0, 0.0055)
X_2<- matrix(NA,nrow = n, ncol = 10)
for(i in seq(1,10)){
X_2[,i]<- sdi.sampler(i, n, sdi_init)
}
colnames(X_2)<- c("no.lags","sdi.alpha","sdi.beta", "theta_1",  "theta_2",
"theta_3", "rho_1", "rho_2", "rho_3","tau")
X<- cbind(X,X_2)
}
for(i in seq(1,11)){
X[,i]<- runif(n, min = limits[i,1], max = limits[i,2])
}
# Generation 1
Y<- numeric(n)
delta_t<- numeric(n)
for(i in seq(1,n)){
if(isTRUE(sdi)){
sdi.pars<- X[i,12:21]
}else{
sdi.pars<- FALSE
}
tic()
Y[i]<- wrapper_interior(sdi = sdi.pars, X[i,1], stoch.round(X[i,2]),
stoch.round(X[i,3]), stoch.round(X[i,4]), X[i,5],
X[i,6], as.logical(stoch.round(X[i,7])), X[i,8],
X[i,9], X[i,10], X[i,11],
inputdf = inputdf, y = y, est.type = est_type,
alpha = alpha, cv = cv, no.trees = no_trees,
no.threads = no_threads,
early.stopping = early_stopping, seed = seed)
im<- toc()
delta_t[i]<- im$toc - im$tic
}
Y_round<- signif(Y, digits = digits[1])
generation.results<- as.data.frame(cbind(X, Y, Y_round, delta_t))|>
arrange(Y_round,delta_t)
results[[1]]<- generation.results
best.in.class<- generation.results[1,]
# Generation 2+
for(s in seq(2,maxiter)){
set.seed(optim.seed + s)
X_new<- X
mutation.matrix<- matrix(runif(n * ncol(X)), nrow = n) <= pmutation
for(i in seq(1,n)){
parents<- X[sample(1:elitism, 2, replace = FALSE),]
for(j in seq(1,ncol(X_new))){
if(mutation.matrix[i,j]){
if(j <= 11){
X_new[i,j]<- runif(1, min = limits[j,1], max = limits[j,2])
}else{
X_new[i,j]<- sdi.sampler(j - 11, 1, sdi_init)
}
}else{
X_new[i,j]<- sample(c(parents[1,j],parents[2,j], mean(parents[,j])),
1, prob = c(rep(0.5 * (1 - pcrossover), 2),
pcrossover))
}
}
}
X<- X_new
Y<- numeric(n)
delta_t<- numeric(n)
for(i in seq(1,n)){
if(isTRUE(sdi)){
sdi.pars<- X[i,12:21]
sdi.pars[1]<- stoch.round(sdi.pars[1])
}else{
sdi.pars<- FALSE
}
tic()
Y[i]<- wrapper_interior(sdi = sdi.pars, X[i,1], stoch.round(X[i,2]),
stoch.round(X[i,3]), stoch.round(X[i,4]), X[i,5],
X[i,6], as.logical(stoch.round(X[i,7])), X[i,8],
X[i,9], X[i,10], X[i,11],
inputdf = inputdf, y = y, est.type = est_type,
alpha = alpha, cv = cv, no.trees = no_trees,
no.threads = no_threads,
early.stopping = early_stopping, seed = seed)
im<- toc()
delta_t[i]<- im$toc - im$tic
}
Y_round<- signif(Y, digits = digits[s])
generation.results<- as.data.frame(cbind(X, Y, Y_round, delta_t))|>
arrange(Y_round,delta_t)
results[[s]]<- generation.results
if(generation.results$Y_round[1] <= best.in.class$Y_round[1] &
generation.results$delta_t[1] < best.in.class$delta_t[1]){
best.in.class<- generation.results[1,]
}
}
results$best_in_class<- best.in.class
return(results)
}
sdi.sampler<- function(i, no.samples, sdi_init){
# An internal function for genetic.algorithm. Creates a random parameter for the i-th SDI parameter.
# i is the index for the SDI parameter
# no.samples specifies how many samples are drawn for the specified parameter
# sdi_init the expected value of the parameters 4 to 10.
if(i==1){
1 + rbetabinom.ab(no.samples, 20, 1.2, 1.2 * 13/7) #no. lags
}else if(i==2){
runif(no.samples, min = 0, max = 3) #shape1
}else if(i==3){
runif(no.samples, min = 1, max = 8) #shape2
}else if(i>3){
rnorm(no.samples, mean = sdi_init[i], sd = 0.25) #theta1-3, rho1-3, tau
}
}
ga2model<- function(ga.list, inputdf, y, est.type, alpha = 0.5,
no.trees = 100L, no.threads = 4L, seed = NA){
# trains the best model specified by the "genetic.algorithm" function. It is based on wrapper_interior, similar to genetic.algorithm.
# ga.list is an output list extracted from the function "genetic.algorithm".
# other parameters are equal to wrapper_interior parameters.
params<- ga.list$best_in_class
if(colnames(inputdf)[1] %in% c("thoms_discomfort_index", "length_heatwave")){
sdi.params<- FALSE
}else{
sdi.params<- c(params$no.lags, params$sdi.alpha, params$sdi.beta,
params$theta_1, params$theta_2, params$theta_3, params$rho_1,
params$rho_2, params$rho_3, params$tau)
}
out<- wrapper_interior(sdi = sdi.params, lr = params$lr,
no.leaves = round(params$no.leaves),
max.depth = round(params$max.depth),
min.data.in.leaf = round(params$min.data.in.leaf),
feature.fraction = params$feature.fraction,
cat.l2 = params$cat.l2,
extra.trees = as.logical(round(params$extra.trees)),
top.rate = params$top.rate,
other.rate = params$other.rate,
cat.smooth = params$cat.smooth,
path.smooth = params$path.smooth,
inputdf = inputdf, y = y, est.type = est.type,
alpha = alpha, cv = 1L, no.trees = no.trees,
no.threads = no.threads)
return(out)
}
ga2performance.eval<- function(ga.list, inputdf, y, est.type, no.trees = 100L,
alpha = 0.5, no.threads = 4L, seed = NA,
cv = 10){
# Measures the performance of the best model specified by the "genetic.algorithm" function.
# ga.list is an output list extracted from the function "genetic.algorithm".
# other parameters are equal to wrapper_interior parameters.
params<- ga.list$best_in_class
if(any(colnames(inputdf) %in% c("thoms_discomfort_index", "length_heatwave"))){
sdi.params<- FALSE
}else{
sdi.params<- c(params$no.lags, params$sdi.alpha, params$sdi.beta,
params$theta_1, params$theta_2, params$theta_3, params$rho_1,
params$rho_2, params$rho_3, params$tau)
}
if(est.type %in% c("binary", "multiclass")){
error_rate<- TRUE
}else{
error_rate<- FALSE
}
out<- wrapper_interior(sdi = sdi.params, lr = params$lr,
no.leaves = round(params$no.leaves),
max.depth = round(params$max.depth),
min.data.in.leaf = round(params$min.data.in.leaf),
feature.fraction = params$feature.fraction,
cat.l2 = params$cat.l2,
extra.trees = as.logical(round(params$extra.trees)),
top.rate = params$top.rate,
other.rate = params$other.rate,
cat.smooth = params$cat.smooth,
path.smooth = params$path.smooth,
inputdf = inputdf, y = y, est.type = est.type,
alpha = alpha, cv = cv, no.trees = no.trees,
no.threads = no.threads, error.rate = error_rate)
return(out)
}
performance.plots<- function(predicted.var, di, practiceID, galist, y.name,
y.range, no.threads = 4){
# Creates plots to evaluate the peformance of the estimated models. Works only for research question 1.
# predicted.var is a string giving the name of the output variable. Can bei either age, gender, phi, or chronic.
# di is the discomfort index, given as "TDI", "HW", or "SDI"
# practiceID is the practiceID for which the data will be filtered.
# y.name is the name of the y axis, a character string
# y.range is a double precision, two element vector giving the range of the y axis
# no.threads is the number of threads used for calculating the daily outcomes.
poss.vars<- c("age", "gender", "phi", "chronic")
mapping<- c("age", "female", "PKV", "no_all_chronic_diseases")
if(predicted.var %in% c("age", "chronic")){
quants<- c(".05", ".25", ".50", ".75", ".95")
ref.df<- full.df_7|>
filter(PraxisID == practiceID)|>
arrange(TG_DateNum)
#predictive df
pred.df<- df_qx(ref.df, di = di, q = 1)
pred.df<- pred.df[!duplicated(ref.df$TG_DateNum),]
if(di == "SDI"){
pred.df$sdi<- ga2sdi(galist, pred.df)
col.deselector<- grepl("temperature", colnames(pred.df)) |
grepl("humidity", colnames(pred.df))
pred.df<- pred.df[,!col.deselector]
}
pred.df<- data.matrix(pred.df)
pred.matrix<- matrix(NA, ncol = 5, nrow = nrow(pred.df))
for(i in seq(1, 5)){
booster<- get(paste0("model_", predicted.var, quants[i], "_", di),
envir = .GlobalEnv)
pred.matrix[,i]<- predict(object = booster, newdata = pred.df)
}
#real data df
pred.mapping<- mapping[predicted.var == poss.vars]
ref.df<- ref.df[c("TG_DateNum", pred.mapping)]
ref.dates<- unique(ref.df$TG_DateNum)
perf.cl<- makeCluster(no.threads)
dist.env<- environment()
clusterExport(cl = perf.cl, varlist = c("ref.dates", "ref.df", "quantile"),
envir = dist.env)
raw.list<- parLapply(cl = perf.cl, X = seq_along(ref.dates), function(k){
ref.date<- ref.dates[k]
ref.vec<- ref.df[ref.df$TG_DateNum == ref.date, 2]
out<- quantile(ref.vec, probs = c(0.05, 0.25, 0.5, 0.75, 0.95),
na.rm = TRUE)
out<- c(ref.date, out)
return(out)
})
ref.matrix<- matrix(unlist(raw.list), ncol = 6, byrow = TRUE)
colnames(ref.matrix)<- c("TG_DateNum", paste0("q", quants))
ref.matrix<- as.data.frame(ref.matrix)|>
arrange(TG_DateNum)
prefix<- paste0("Practice ", practiceID, ", ", predicted.var, " quantiles")
quants_2<- c("5%", "25%", "50%", "75%", "95%")
quants_3<- c("5pct", "25pct", "50pct", "75pct", "95pct")
plot.names<- paste0(prefix, " (", quants_2, ")")
file.names<- paste0(prefix, " ", quants_3, "_", di, ".png")
}else if(predicted.var %in% c("gender", "phi")){
ref.df<- full.df_7|>
filter(PraxisID == practiceID)|>
arrange(TG_DateNum)
#predictive df
pred.df<- df_qx(ref.df, di = di, q = 1)
pred.df<- pred.df[!duplicated(ref.df$TG_DateNum),]
if(di == "SDI"){
pred.df$sdi<- ga2sdi(galist, pred.df)
col.deselector<- grepl("temperature", colnames(pred.df)) |
grepl("humidity", colnames(pred.df))
pred.df<- pred.df[,!col.deselector]
}
pred.df<- data.matrix(pred.df)
booster<- get(paste0("model_", predicted.var, "_", di), envir = .GlobalEnv)
pred.matrix<- matrix(predict(object = booster, newdata = pred.df), ncol = 1)
#real data df
pred.mapping<- mapping[predicted.var == poss.vars]
ref.df<- ref.df[c("TG_DateNum", pred.mapping)]
ref.dates<- unique(ref.df$TG_DateNum)
perf.cl<- makeCluster(no.threads)
dist.env<- environment()
clusterExport(cl = perf.cl, varlist = c("ref.dates", "ref.df", "mean"),
envir = dist.env)
raw.list<- parLapply(cl = perf.cl, X = seq_along(ref.dates), function(k){
ref.date<- ref.dates[k]
ref.vec<- ref.df[ref.df$TG_DateNum == ref.date, 2]
out<- mean(ref.vec, na.rm = TRUE)
out<- c(ref.date, out)
return(out)
})
ref.matrix<- matrix(unlist(raw.list), ncol = 2, byrow = TRUE)
colnames(ref.matrix)<- c("TG_DateNum", "proportion")
ref.matrix<- as.data.frame(ref.matrix)|>
arrange(TG_DateNum)
if(predicted.var == "phi"){
plot.names<- paste0("Practice ", practiceID,
", proportion privately insured")
file.names<- paste0("Practice ", practiceID,
", proportion privately insured", "_", di, ".png")
}else{
plot.names<- paste0("Practice ", practiceID,
", proportion female patients")
file.names<- paste0("Practice ", practiceID,
", proportion female patients", "_", di, ".png")
}
}
#generate plots
no.plots<- ncol(pred.matrix)
for(i in seq(1, no.plots)){
#x axis configuration
data.start.month<- month(TG_DateNum2date(ref.matrix[1, 1]))
data.end.month<- month(TG_DateNum2date(ref.matrix[nrow(ref.matrix), 1]))
if(data.start.month == 1){
axis.start.month<- 1
}else{
axis.start.month<- data.start.month - (data.start.month - 1) %% 3
}
if(data.end.month == 12){
axis.end.month<- 12
}else{
axis.end.month<- data.end.month + 3 - (data.end.month - 1) %% 3
}
data.start.year<- isoyear(TG_DateNum2date(ref.matrix[1, 1]))
data.end.year<- isoyear(TG_DateNum2date(ref.matrix[nrow(ref.matrix), 1]))
if(data.end.month >= 10){
axis.end.year<- data.end.year + 1
}else{
axis.end.year<- data.end.year
}
axis.start.date<- as.Date(paste(data.start.year, axis.start.month, "01",
sep = "-"))
axis.end.date<- as.Date(paste(axis.end.year, axis.end.month, "01",
sep = "-"))
no.years<- axis.end.year - data.start.year + 1
tick.df<- data.frame(
month= rep(c(1, 4, 7, 10), no.years),
year= sort(rep(seq(data.start.year, axis.end.year), 4))
)
tick.df<- tick.df|>
filter((month >= axis.start.month ) | (year != data.start.year))|>
filter((month <= axis.end.month) | (year != axis.end.year))
tick.df$date<- as.Date(paste(tick.df$year, tick.df$month, "01", sep = "-"))
tick.df$print_date<- paste(tick.df$month, tick.df$year, sep = "/")
tick.df$TG_DateNum<- date2TG_DateNum(tick.df$date)
png(file.names[i])
plot(ref.matrix[,i + 1] ~ ref.matrix[,1], type = "l", xlab = "time",
ylab = y.name, main = plot.names[i], ylim = y.range, las = 1,
xaxt = "n", xlim = range(tick.df$TG_DateNum),
sub = paste("black solid line: real data,",
"red dotted line: prediction based on", di))
axis(side = 1, at = tick.df$TG_DateNum, labels = tick.df$print_date)
lines(x = ref.matrix[,1], y = pred.matrix[,i], col = "red", lty = 3)
dev.off()
}
}
ga2sdi<- function(galist, inputdf){
#Returns the SDI vector for any data frame which has needed columns to calculate SDI. The parameterisation is directly imported from a list generated through the "genetic.algorithm" function.
sdi<- unlist(galist$best_in_class[12:21])
sdi.weights<- dbetabinom.ab(x = seq(0,sdi[1]), size = sdi[1], shape1 = sdi[2],
shape2 = sdi[3])
out<- SDI(df = as.data.frame(inputdf), w = sdi.weights, theta = sdi[4:6], rho = sdi[7:9],
tau = sdi[10])
return(out)
}
model.eval<- function(booster, DI, sdi, Q, no.draws, eval.var, eval.seq, seed,
y.max, y.name, x.factor.names = NA,
y.label = "proportion"){
# simulates data from a booster and a df_qx-created data frame. Returns for each outcome of the 'dependent' variable a plot with evaluation results, dependent on what the booster predicts. The plots are saved to the working directory.
# booster is a booster, extracted from ga2model
# DI is the discomfort index, given as "TDI", "HW", or "SDI"
# sdi is the vector of SDI hyperparameters iff DI == "SDI"
# Q is the numeric research question (either 1 or 2). It is fed into df_qx.
# eval.var is the name of the variable that will be varied. In the returned plots, it will be on the x-axis.
# eval.seq is the sequence of variables that will be inserted for the evaluated variable.
# seed is the random seed.
# y.max is the upper limit of the y axis.
# y.name is the name of the 'dependent' variable for research question 1. It is used in the naming of the plot and the file that the plot is saved to.
# x.factor.names is an optional vector of names attached to the numeric values of x. This is especially important for factor variables.
# y.label is the optional name attached to the y axis of the plot.
inputdf<- df_qx(di = DI, q = Q)
blacklist<- c("thoms_discomfort_index", "length_heatwave", "sdi",
"daylight_hours", "covid_7_day_incidence", "age",
colnames(inputdf)[grep("chronic", colnames(inputdf))])
if(DI == "SDI"){
sdi.weights<- dbetabinom.ab(x = seq(0,sdi[1]), size = sdi[1],
shape1 = sdi[2], shape2 = sdi[3])
sdi.vec<- SDI(df = inputdf, w = sdi.weights, theta = sdi[4:6],
rho = sdi[7:9], tau = sdi[10])
col.selector<- grepl("temperature", colnames(inputdf)) | grepl("humidity", colnames(inputdf))
df<- inputdf[,!col.selector]
df$sdi<- sdi.vec
factor.vars<- colnames(df)[!colnames(df) %in% blacklist]
df<- data.matrix(df)
}else{
factor.vars<- colnames(inputdf)[!colnames(inputdf) %in% blacklist]
df<- data.matrix(inputdf)
}
set.seed(seed)
initial.data<- df[sample(seq(1, nrow(inputdf)), no.draws, replace = FALSE),]
eval.data<- as.data.frame(matrix(NA, nrow = no.draws * length(eval.seq),
ncol = ncol(df)))
colnames(eval.data)<- colnames(df)
eval.var.col<- which(colnames(eval.data)==eval.var)
for(i in seq_along(eval.seq)){
sel.rows<- seq(1, no.draws) + (i - 1) * no.draws
eval.data[sel.rows,]<- initial.data
eval.data[sel.rows,eval.var.col]<- eval.seq[i]
}
prediction.output<- matrix(predict(object = booster,
newdata = data.matrix(eval.data),
type = "response"),
nrow = nrow(eval.data))
k<- ncol(prediction.output)
possible.var.names<- c("thoms_discomfort_index", "PraxisID", "dow",
"public_holiday", "school_holiday", "week_of_month",
"month", "year", "daylight_hours",
"covid_7_day_incidence", "age", "female", "PKV",
"smoking", "alcohol", "sport", "chronic_1",
"chronic_2", "chronic_3", "chronic_4", "chronic_5",
"chronic_6", "chronic_7", "chronic_8", "chronic_9",
"chronic_10", "chronic_11", "no_all_chronic_diseases",
"length_heatwave", "sdi")
possible.xlab.names<- c("Thom's discomfort index", "practice no.",
"day of the week", "public holiday", "school holiday",
"week of the month", "month", "year",
"daylight hours", "Covid-19 7-day-incidence", "age",
"gender", "health insurance", "smoking", "alcohol",
"sport", "chronic cold-related injuries",
"chronic injuries due to excessive heat",
"chronic major cardivascular diseases",
"chronic major external causes for injury",
"chronic mental and behavioural disorders",
"chronic diseases of the respiratory system",
"chronic endocrine, nutritional, and metabolic disorders",
"chronic diseases of the digestive system",
"chronic genitourinary disorders",
"chronic musculoskeletal disorders",
"chronic other diseases and injuries",
"all chronic diseases", "length heatwave",
"suggested discomfort index")
x.name<- possible.xlab.names[eval.var == possible.var.names]
for(l in seq(1, k)){
if(Q == 2){
y.names<- c("cold-related injuries",
"injuries due to excessive heat",
"major cardivascular diseases",
"major external causes for injury",
"mental and behavioural disorders",
"diseases of the respiratory system",
"endocrine, nutritional, and metabolic disorders",
"diseases of the digestive system",
"genitourinary disorders",
"musculoskeletal disorders",
"other diseases and injuries")
plot.name<- paste("Effects of", x.name, "on", y.names[l])
file.name<- paste0(x.name, "_", y.names[l], ".png")
}else{
plot.name<- paste("Effects of", x.name, "on", y.name)
file.name<- paste0(x.name, "_", y.name, ".png")
}
png(file.name)
sel<- seq(1, nrow(eval.data), by = no.draws)
if(length(x.factor.names)>=2){
plot(prediction.output[sel, l]~eval.data[sel, eval.var.col], type = "l",
xlab = x.name, ylab = y.label, main = plot.name, ylim = c(0, y.max),
las = 1, xaxt = "n")
axis(side = 1, at = eval.seq, labels = x.factor.names)
}else{
plot(prediction.output[sel, l]~eval.data[sel, eval.var.col], type = "l",
xlab = x.name, ylab = y.label, main = plot.name, ylim = c(0, y.max),
las = 1)
}
for(i in seq(2, no.draws)){
sel<- sel + 1
lines(x = eval.data[sel, eval.var.col], y = prediction.output[sel, l])
}
dev.off()
}
}
